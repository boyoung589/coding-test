# 점프와 순간 이동

# 💡**문제 분석 요약**

- 점프: 거리+=1, 건전지 사용량 +=1
- 순간이동: 거리+=(지금까지 이동거리)*2, 건전지 사용량 +=0
- 총 가야하는 거리가 n일 때, 건전지 사용량의 최솟값 구하기
- 제한 사항
    - 숫자 N: 1 이상 10억 이하의 자연수
    - 숫자 K: 1 이상의 자연수

# 💡**알고리즘 설계**

- 가장 짧게 배터리를 사용하기 위해선 총 가야하는 거리의 절반에서 순간이동하는 과정을 반복하면 된다.
- 총 거리가 0보다 큰 동안 반복
    - 2로 나눈 나머지가 0인 경우 ⇒ 순간이동
        - 총 거리는 2로 나눈 몫이되고, 배터리는 변화가 없다.
    - 2로 나눈 나머지가 0이 아닌 경우 ⇒ 점프
        - 총 거리 -1을 해주고, 배터리를 +1 해준다.
- ~~하지만 2로 나누다보니 n이 1인 경우와 2인 경우 원하는 결과가 나오지 않으므로 위에 따로 규정해 준다.~~ `⇒ 원하는 결과 나옴`
    - ~~n이 1이면 battery는 1~~
    - ~~n이 2이면 battery는 1~~

# 💡코드

```jsx
function solution(n){
    let battery = 0;
    while(n > 0){
        if(n % 2 === 0){
            n /= 2;
        } else{
            n -= 1;
            battery++;
        }
    }
    return battery;
}
```

# 💡시간복잡도

- O(logN): 2로 계속 나누기 때문에 logN 추정

# 💡 틀린 이유

- 접근방식이 틀림
    - 앞에서부터 계속 더하는 것으로 생각했으나 battery의 최소량이 아님.
        
        ```jsx
        1. 지금까지 간 거리를 나타내는 숫자 변수 moved 선언
        2. 건전지 사용량을 나타내는 숫자 변수 battery 선언
        3. 
        4. 처음 1칸은 무조건 점프해야하므로 moved++, battery++
        5. moved === n일때까지 반복
            1. moved*2가 n보다 작으면
                1. moved += moved * 2
            2. moved*2가 n보다 크면
                1. moved++, battery++
        6. battery리턴
        ```
        
- battery++을 먼저 해줄 필요가 없음 ⇒ 어차피 2로 안나눠지면 1칸 가므로
- n이 2인 경우, 1인 경우도 while문 범위안에 들어가므로 따로 지정해줄 필요 없음

# 💡 틀린 부분 수정 or 다른 풀이

# 💡 느낀점 or 기억할정보

- 종이에 써서 푸는 것이 좋다.
- 예시 문제를 종이에 풀면서 보고 풀이법을 생각해보자
